{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoveIt - an HackaGame game MoveIt est a un jeu vid\u00e9o imagin\u00e9 sur un aspect p\u00e9dagogique pour le challenge de d\u00e9velopper des joueurs IA. Il s'articule autour du probl\u00e8me de chemins multiagent ( Multi-agent pathfinding ). Cependant, au-del\u00e0 du probl\u00e8me d\u2019\u00e9vitement de collision le but est: Deprendre en charge des missions al\u00e9atoires, Avec des \u00e9quipes en concurrence sur le terrain Avec des Vips \u00e0 \u00e9viter absolument. MoveIt est acc\u00e9ssible via son repo-git , merci \u00e0 github pour ce service. Briques technologiques Pour ce faire MoveIt s'appuie sur HackaGames une libraire modeste bas\u00e9e sur ZeroMQ pour s\u00e9parer le processus du jeu (le ma\u00eetre du jeu) et les joueurs autonomes ( Bot ). ZeroMQ se veux \u00eatre une An open-source universal messaging library . Par universel, il faut entendre Connecting your code in any language, on any platform . Cependant, aujourd\u2019hui HackaGames est d\u00e9velopp\u00e9 exclusivement sous Python3 . Objectifs Mises-en oeuvre de techniques d'optimisation combinatoire et d'Intelligence Artificielle. Conduire un projet de fa\u00e7on it\u00e9ratif. Travailler en \u00e9quipes. Int\u00e9grer de bonne pratique de d\u00e9veloppement de projet informatique (versionning, tests, documentation).","title":"Home"},{"location":"#moveit-an-hackagame-game","text":"MoveIt est a un jeu vid\u00e9o imagin\u00e9 sur un aspect p\u00e9dagogique pour le challenge de d\u00e9velopper des joueurs IA. Il s'articule autour du probl\u00e8me de chemins multiagent ( Multi-agent pathfinding ). Cependant, au-del\u00e0 du probl\u00e8me d\u2019\u00e9vitement de collision le but est: Deprendre en charge des missions al\u00e9atoires, Avec des \u00e9quipes en concurrence sur le terrain Avec des Vips \u00e0 \u00e9viter absolument. MoveIt est acc\u00e9ssible via son repo-git , merci \u00e0 github pour ce service.","title":"MoveIt - an HackaGame game"},{"location":"#briques-technologiques","text":"Pour ce faire MoveIt s'appuie sur HackaGames une libraire modeste bas\u00e9e sur ZeroMQ pour s\u00e9parer le processus du jeu (le ma\u00eetre du jeu) et les joueurs autonomes ( Bot ). ZeroMQ se veux \u00eatre une An open-source universal messaging library . Par universel, il faut entendre Connecting your code in any language, on any platform . Cependant, aujourd\u2019hui HackaGames est d\u00e9velopp\u00e9 exclusivement sous Python3 .","title":"Briques technologiques"},{"location":"#objectifs","text":"Mises-en oeuvre de techniques d'optimisation combinatoire et d'Intelligence Artificielle. Conduire un projet de fa\u00e7on it\u00e9ratif. Travailler en \u00e9quipes. Int\u00e9grer de bonne pratique de d\u00e9veloppement de projet informatique (versionning, tests, documentation).","title":"Objectifs"},{"location":"bots/","text":"First Autonomous Player (Bot) MoveIt est bas\u00e9 sur HackaGames . Se r\u00e9f\u00e9rer \u00e0 cette solution pour la philosophie du moteur de jeu, et des \u00e9changes entre le Ma\u00eetre de jeu et les joueurs. Documentation de HackaGames : ktorz-net.github.io/hackagames/ Pour lancer son premier Bot sur MoveIt il faut alors \u00e9diter un script de lancement comme suit ( launch.py par exmple). import hacka.games.moveit as moveit import playground from hacka.command import Command, Option # Configure the game: gameEngine= moveit.GameEngine() # Then Go... gameMaster= moveit.GameMaster( gameEngine, randomMission=2 ) player= playground.FirstBot() gameMaster.launch( [player], gameEngine.numberOfPlayers() ) Cela supose naturellement d'avoir une class FirstBot dans un fichier playground.py , \u00e0 c\u00f4t\u00e9 de votre lanceur. Squelette de joueur: MoveIt se structure comme tout jeu HackaGames avec un cycle global: wakeUp en d\u00e9but de partie et sleep en fin de partie, et un cycle rapide de tour de jeu avec perceive et decide . class FirstBot(): # Player interface : def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): pass def perceive(self, state ): pass def decide(self): return \"pass\" def sleep(self, result): print( f\"end on : {result}\" ) Dans la mesure ou FirstBot d\u00e9finie les m\u00e9thodes appropri\u00e9es avec les parram\u00e9tres coh\u00e9rents, une instance de FirstBot pourra jouer dans un jeu HackaGames . Naturellement, dans l'\u00e9tat, le r\u00e9sultat sera null. python3 launch.py Le gameConfiguration de la m\u00e9thode wakeUp d\u00e9fini le plateau de jeu. Les cellules et comment elles sont connect\u00e9 les unes au autre. Au passage on a d\u00e9s le wakeUp , la position des robots et le 'Market Place' avec les missions diponible. Ensuite, la m\u00e9thode perceive avec cont parram\u00e9tre state ne va renseigner que sur l'avanc\u00e9 du jeux. Le positionnement des robots surle plateau et l'avanc\u00e9 des missions. Cependant il n'est pas utile de rentre dans le d\u00e9tail des object gameConfiguration et state . Il est possible de charger un mod\u00e9le du jeu, avec la class GameEngine du package python moveIt . Il sera alors possible de carger la caonfiguration du jeu et de mettre \u00e0 jour son \u00e9tat simplement: from hacka.games.moveit import GameEngine ... def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): self._model= GameEngine() self._model.fromPod(gameConfiguration) # Load the model from gameConfiguration self._model.render() # Draw the game image in shot-moveIt.png def perceive(self, state ): self._model.setOnState(state) # Update the model sate Then model will be querry throught its methods (look at inspect python package for instance). MoveIt model (GameEngine class): Let take a look at GameEngine accessor methods: def numberOfPlayers(self): Return the number of players. def numberOfRobots(self, iPlayer=1): Return the number of robots owned by the player identifiate as iPlayer . def mobile(self, iPlayer, iRobot): Return the iRobot th robot as a Mobile instance of the player iPlayer . A Mobile as several well named methods: owner() (should be equal to iPlayer ), identifier() (should be equal to iRobot ) and mission() the identifier of the current robot mission. def mobilePosition(self, iPlayer, iRobot): return the position (tile identifier) of the iRobot th robot of the player iPlayer . def missions(self): return all missions tuples. def mission(self, iMission): Return the tuple describing the iMission th mission (tile from, tile to, payment, allocation to player) def missionsList(self): return the list of active missions identifiers. def freeMissions(self): Return the list of mission identifier not allocated to any players. def tic( self ): Return the counter on game turn. def score(self, iPlayer): Return the score of the iPlayer player.","title":"Bot player"},{"location":"bots/#first-autonomous-player-bot","text":"MoveIt est bas\u00e9 sur HackaGames . Se r\u00e9f\u00e9rer \u00e0 cette solution pour la philosophie du moteur de jeu, et des \u00e9changes entre le Ma\u00eetre de jeu et les joueurs. Documentation de HackaGames : ktorz-net.github.io/hackagames/ Pour lancer son premier Bot sur MoveIt il faut alors \u00e9diter un script de lancement comme suit ( launch.py par exmple). import hacka.games.moveit as moveit import playground from hacka.command import Command, Option # Configure the game: gameEngine= moveit.GameEngine() # Then Go... gameMaster= moveit.GameMaster( gameEngine, randomMission=2 ) player= playground.FirstBot() gameMaster.launch( [player], gameEngine.numberOfPlayers() ) Cela supose naturellement d'avoir une class FirstBot dans un fichier playground.py , \u00e0 c\u00f4t\u00e9 de votre lanceur.","title":"First Autonomous Player (Bot)"},{"location":"bots/#squelette-de-joueur","text":"MoveIt se structure comme tout jeu HackaGames avec un cycle global: wakeUp en d\u00e9but de partie et sleep en fin de partie, et un cycle rapide de tour de jeu avec perceive et decide . class FirstBot(): # Player interface : def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): pass def perceive(self, state ): pass def decide(self): return \"pass\" def sleep(self, result): print( f\"end on : {result}\" ) Dans la mesure ou FirstBot d\u00e9finie les m\u00e9thodes appropri\u00e9es avec les parram\u00e9tres coh\u00e9rents, une instance de FirstBot pourra jouer dans un jeu HackaGames . Naturellement, dans l'\u00e9tat, le r\u00e9sultat sera null. python3 launch.py Le gameConfiguration de la m\u00e9thode wakeUp d\u00e9fini le plateau de jeu. Les cellules et comment elles sont connect\u00e9 les unes au autre. Au passage on a d\u00e9s le wakeUp , la position des robots et le 'Market Place' avec les missions diponible. Ensuite, la m\u00e9thode perceive avec cont parram\u00e9tre state ne va renseigner que sur l'avanc\u00e9 du jeux. Le positionnement des robots surle plateau et l'avanc\u00e9 des missions. Cependant il n'est pas utile de rentre dans le d\u00e9tail des object gameConfiguration et state . Il est possible de charger un mod\u00e9le du jeu, avec la class GameEngine du package python moveIt . Il sera alors possible de carger la caonfiguration du jeu et de mettre \u00e0 jour son \u00e9tat simplement: from hacka.games.moveit import GameEngine ... def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): self._model= GameEngine() self._model.fromPod(gameConfiguration) # Load the model from gameConfiguration self._model.render() # Draw the game image in shot-moveIt.png def perceive(self, state ): self._model.setOnState(state) # Update the model sate Then model will be querry throught its methods (look at inspect python package for instance).","title":"Squelette de joueur:"},{"location":"bots/#moveit-model-gameengine-class","text":"Let take a look at GameEngine accessor methods: def numberOfPlayers(self): Return the number of players. def numberOfRobots(self, iPlayer=1): Return the number of robots owned by the player identifiate as iPlayer . def mobile(self, iPlayer, iRobot): Return the iRobot th robot as a Mobile instance of the player iPlayer . A Mobile as several well named methods: owner() (should be equal to iPlayer ), identifier() (should be equal to iRobot ) and mission() the identifier of the current robot mission. def mobilePosition(self, iPlayer, iRobot): return the position (tile identifier) of the iRobot th robot of the player iPlayer . def missions(self): return all missions tuples. def mission(self, iMission): Return the tuple describing the iMission th mission (tile from, tile to, payment, allocation to player) def missionsList(self): return the list of active missions identifiers. def freeMissions(self): Return the list of mission identifier not allocated to any players. def tic( self ): Return the counter on game turn. def score(self, iPlayer): Return the score of the iPlayer player.","title":"MoveIt model (GameEngine class):"},{"location":"rules/","text":"R\u00e9gles du jeux MoveIt consiste donc \u00e0 d\u00e9placer des robots dans une carte pour r\u00e9alis\u00e9r des missions. Un randu visuel est propos\u00e9 \u00e0 l'aide de la librairie graphique Cairo . Ci appr\u00e9s une capture d'\u00e9crant du jeux: On peu y voir 3 robots rouges ( R-1 , R-2 et R-3 ) pouvant se d\u00e9placer sur un graphe compos\u00e9 de 48 cellules/dalles ( tiles en anglais) Un Market-Place propose des missions \u00e0 r\u00e9aliser par les robots. Jouer: Nous supposons ici que vous avais clonez MoveIt et que vous l'avez install\u00e9 sur votre machine. Le r\u00e9pertoire play contiend un certaint nombre de scripts ( \\(2\\) pour l'instant), permetant de lancer MoveIT dans diff\u00e9rente configuration dans un mode interactif. Vous, humain, jouez au jeu en envoyant vos commands dans le terminal. Lancer le jeu dans son mode le plus basic: python3 ./game-moveit/play/debug.py Une repr\u00e9sentation du jeux est mise \u00e0 jour \u00e0 chaque pas-de-temps dans ./shot-moveIt.png pour avoir une id\u00e9e de l'\u00e9tat du jeu est prendre les bonnes d\u00e9cisions. Les d\u00e9cisions consernent en premier lieu les d\u00e9placement des robots et se code de la pa\u00e7on suivante: move iRobot direction . Chaque robot donc est identifi\u00e9 par un num\u00e9ro de \\(1\\) \u00e0 \\(n\\) avec \\(n\\) robots. La direction est cod\u00e9 sur une logique horaire ( Clock Bearing ). Le robot peut se d\u00e9pacer \u00e0 midi, 3 heure, 6 heure ou 9 heure. Par exemple avec trois robots: move 1 9 2 12 3 3 Cet commande indique que le robot-1 bouge dans la direction 9H, le robot-2 vers 12h et le robot-3 vers 3H. Une direction \\(0h\\) indiquera que le rbots reste sur sa position (action par d\u00e9fault). Les robots peuvent r\u00e9aliser une mission, soit pour la d\u00e9buter, soit pour la finaliser. Dans ce cadre, le robot doit \u00eatre sur la bonne possition pour faire une action mission : mission iRobot iMission . iMission est l'identifiant de la mission \u00e0 activer ou a finaliser entre \\(1\\) et \\(m\\) avec \\(m\\) missions sur le jeu. L'example suivant indique que le robot-2 active la mission 8 . mission 2 8 \u00e0 noter que \\(2\\) mission ne raporteront pas n\u00e9cc\u00e9ssairement le m\u00eame nombre de cr\u00e9dit (\u00a2). L'\u00e9quipe de robot \u00e0 un nombre de tours (tic) limit\u00e9 pour r\u00e9aliser un maximun de mission. Aussi, il est pr\u00e9f\u00e9rable de faire les actions missions en m\u00eame temps que des d\u00e9placements des autres robots, par exemple: mission 2 8 move 1 0 3 12 Pour un version plus riche du jeu: python3 ./game-moveit/play/moveIt.py Version multi-joueur","title":"Game Rules"},{"location":"rules/#regles-du-jeux","text":"MoveIt consiste donc \u00e0 d\u00e9placer des robots dans une carte pour r\u00e9alis\u00e9r des missions. Un randu visuel est propos\u00e9 \u00e0 l'aide de la librairie graphique Cairo . Ci appr\u00e9s une capture d'\u00e9crant du jeux: On peu y voir 3 robots rouges ( R-1 , R-2 et R-3 ) pouvant se d\u00e9placer sur un graphe compos\u00e9 de 48 cellules/dalles ( tiles en anglais) Un Market-Place propose des missions \u00e0 r\u00e9aliser par les robots.","title":"R\u00e9gles du jeux"},{"location":"rules/#jouer","text":"Nous supposons ici que vous avais clonez MoveIt et que vous l'avez install\u00e9 sur votre machine. Le r\u00e9pertoire play contiend un certaint nombre de scripts ( \\(2\\) pour l'instant), permetant de lancer MoveIT dans diff\u00e9rente configuration dans un mode interactif. Vous, humain, jouez au jeu en envoyant vos commands dans le terminal. Lancer le jeu dans son mode le plus basic: python3 ./game-moveit/play/debug.py Une repr\u00e9sentation du jeux est mise \u00e0 jour \u00e0 chaque pas-de-temps dans ./shot-moveIt.png pour avoir une id\u00e9e de l'\u00e9tat du jeu est prendre les bonnes d\u00e9cisions. Les d\u00e9cisions consernent en premier lieu les d\u00e9placement des robots et se code de la pa\u00e7on suivante: move iRobot direction . Chaque robot donc est identifi\u00e9 par un num\u00e9ro de \\(1\\) \u00e0 \\(n\\) avec \\(n\\) robots. La direction est cod\u00e9 sur une logique horaire ( Clock Bearing ). Le robot peut se d\u00e9pacer \u00e0 midi, 3 heure, 6 heure ou 9 heure. Par exemple avec trois robots: move 1 9 2 12 3 3 Cet commande indique que le robot-1 bouge dans la direction 9H, le robot-2 vers 12h et le robot-3 vers 3H. Une direction \\(0h\\) indiquera que le rbots reste sur sa position (action par d\u00e9fault). Les robots peuvent r\u00e9aliser une mission, soit pour la d\u00e9buter, soit pour la finaliser. Dans ce cadre, le robot doit \u00eatre sur la bonne possition pour faire une action mission : mission iRobot iMission . iMission est l'identifiant de la mission \u00e0 activer ou a finaliser entre \\(1\\) et \\(m\\) avec \\(m\\) missions sur le jeu. L'example suivant indique que le robot-2 active la mission 8 . mission 2 8 \u00e0 noter que \\(2\\) mission ne raporteront pas n\u00e9cc\u00e9ssairement le m\u00eame nombre de cr\u00e9dit (\u00a2). L'\u00e9quipe de robot \u00e0 un nombre de tours (tic) limit\u00e9 pour r\u00e9aliser un maximun de mission. Aussi, il est pr\u00e9f\u00e9rable de faire les actions missions en m\u00eame temps que des d\u00e9placements des autres robots, par exemple: mission 2 8 move 1 0 3 12 Pour un version plus riche du jeu: python3 ./game-moveit/play/moveIt.py","title":"Jouer:"},{"location":"rules/#version-multi-joueur","text":"","title":"Version multi-joueur"}]}