{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MoveIt - an HackaGame game MoveIt est a un jeu vid\u00e9o imagin\u00e9 sur un aspect p\u00e9dagogique pour le challenge de d\u00e9velopper des joueurs IA. Il s'articule autour du probl\u00e8me de chemins multiagent ( Multi-agent pathfinding ). Cependant, au-del\u00e0 du probl\u00e8me d\u2019\u00e9vitement de collision le but est: Deprendre en charge des missions al\u00e9atoires, Avec des \u00e9quipes en concurrence sur le terrain Avec des Vips \u00e0 \u00e9viter absolument. MoveIt est acc\u00e9ssible via son repo-git , merci \u00e0 github pour ce service. Briques technologiques Pour ce faire MoveIt s'appuie sur HackaGames une libraire modeste bas\u00e9e sur ZeroMQ pour s\u00e9parer le processus du jeu (le ma\u00eetre du jeu) et les joueurs autonomes ( Bot ). ZeroMQ se veux \u00eatre une An open-source universal messaging library . Par universel, il faut entendre Connecting your code in any language, on any platform . Cependant, aujourd\u2019hui HackaGames est d\u00e9velopp\u00e9 exclusivement sous Python3 . Objectifs Mises-en oeuvre de techniques d'optimisation combinatoire et d'Intelligence Artificielle. Conduire un projet de fa\u00e7on it\u00e9ratif. Travailler en \u00e9quipes. Int\u00e9grer de bonne pratique de d\u00e9veloppement de projet informatique (versionning, tests, documentation).","title":"Home"},{"location":"#moveit-an-hackagame-game","text":"MoveIt est a un jeu vid\u00e9o imagin\u00e9 sur un aspect p\u00e9dagogique pour le challenge de d\u00e9velopper des joueurs IA. Il s'articule autour du probl\u00e8me de chemins multiagent ( Multi-agent pathfinding ). Cependant, au-del\u00e0 du probl\u00e8me d\u2019\u00e9vitement de collision le but est: Deprendre en charge des missions al\u00e9atoires, Avec des \u00e9quipes en concurrence sur le terrain Avec des Vips \u00e0 \u00e9viter absolument. MoveIt est acc\u00e9ssible via son repo-git , merci \u00e0 github pour ce service.","title":"MoveIt - an HackaGame game"},{"location":"#briques-technologiques","text":"Pour ce faire MoveIt s'appuie sur HackaGames une libraire modeste bas\u00e9e sur ZeroMQ pour s\u00e9parer le processus du jeu (le ma\u00eetre du jeu) et les joueurs autonomes ( Bot ). ZeroMQ se veux \u00eatre une An open-source universal messaging library . Par universel, il faut entendre Connecting your code in any language, on any platform . Cependant, aujourd\u2019hui HackaGames est d\u00e9velopp\u00e9 exclusivement sous Python3 .","title":"Briques technologiques"},{"location":"#objectifs","text":"Mises-en oeuvre de techniques d'optimisation combinatoire et d'Intelligence Artificielle. Conduire un projet de fa\u00e7on it\u00e9ratif. Travailler en \u00e9quipes. Int\u00e9grer de bonne pratique de d\u00e9veloppement de projet informatique (versionning, tests, documentation).","title":"Objectifs"},{"location":"bots/","text":"First Autonomous Player (Bot) MoveIt est bas\u00e9 sur HackaGames . Se r\u00e9f\u00e9rer \u00e0 cette solution pour la philosophie du moteur de jeu, et des \u00e9changes entre le Ma\u00eetre de jeu et les joueurs. Documentation de HackaGames : ktorz-net.github.io/hackagames/ Pour lancer son premier Bot sur MoveIt il faut alors \u00e9diter un script de lancement comme suit ( launch.py par exmple). import hacka.games.moveit as moveit import playground # Configure the game: gameEngine= moveit.GameEngine() # Then Go... gameMaster= moveit.GameMaster( gameEngine, randomMission=2 ) player= playground.FirstBot() gameMaster.launch( [player], gameEngine.numberOfPlayers() ) Cela supose naturellement d'avoir une class FirstBot dans un fichier playground.py , \u00e0 c\u00f4t\u00e9 de votre lanceur. Blanc Bot Player MoveIt se structure comme tout jeu HackaGames avec un cycle global: wakeUp en d\u00e9but de partie et sleep en fin de partie, et un cycle rapide de tour de jeu avec perceive et decide . class FirstBot(): # Player interface : def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): pass def perceive(self, state ): pass def decide(self): return \"pass\" def sleep(self, result): print( f\"end on : {result}\" ) Dans la mesure o\u00f9 FirstBot d\u00e9finit les m\u00e9thodes appropri\u00e9es avec les param\u00e8tres coh\u00e9rents, une instance de FirstBot pourra jouer dans un jeu HackaGames . Naturellement, dans l'\u00e9tat, le r\u00e9sultat sera nul. python3 launch.py Le gameConfiguration de la m\u00e9thode wakeUp d\u00e9finit le plateau de jeu. Les cellules et comment elles sont connect\u00e9es les unes aux autres. Au passage on a d\u00e9s le wakeUp , la position des robots et le 'Market Place' avec les missions disponibles. Ensuite, la m\u00e9thode perceive avec comme param\u00e8tre state ne va renseigner que sur l'avanc\u00e9e du jeu. Le positionnement des robots sur le plateau et l'avanc\u00e9e des missions. Cependant il n'est pas utile de rentre dans le d\u00e9tail des objets gameConfiguration et state . Il est possible de charger un mod\u00e8le du jeu, avec la class GameEngine du package python moveIt . Il sera alors possible de charger la configuration du jeu et de mettre \u00e0 jour son \u00e9tat simplement: from hacka.games.moveit import GameEngine ... def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): self._id= playerId self._model= GameEngine() self._model.fromPod(gameConfiguration) # Load the model from gameConfiguration self._model.render() # Draw the game image in shot-moveIt.png def perceive(self, state ): self._model.setOnState(state) # Update the model sate Then model will be queried through its methods (look at inspect python package for instance). MoveIt Classes MoveIt game is mainly based on 3 classe: GameEngine : it manages the game elements and the game rules. Map : based on Hackapy::tiled.Map , it represents the environment as a graph of interconnected tiles. Mobile : the mobile objects on the Map (Robots, and Vips). Mission : the mission objects with start and final positions plus reward and owner information. GameEngine Class's methods: numberOfPlayers() - Return the number of players. numberOfMobiles(iPlayer=1) - Return the number of robots owned by the player identifiate as iPlayer or vips, if iPlayer=0 . mobile(iPlayer, iRobot) - Return the iRobot th robot as a Mobile instance of the player iPlayer . mobilePosition(iPlayer, iRobot) - Return the position (tile identifier) of the iRobot th robot of the player iPlayer . missions() - Return all missions tuples. mission(iMission) - Return an object describing the iMission th mission (Mission has 4 integer attributes: the start tile id, the final tile id, the expected reward by terminating the mission and the mission owner id ( \\(0\\) if the mission is free). missionsList() - Return the list of active missions identifiers. freeMissions() - Return the list of mission identifier not allocated to any players. tic() - Return the counter on game turn. score(iPlayer): - Return the score of the iPlayer player. map() - Return the gameEngine map. Map Class's methods: To notice that MoveIt Map inherits from HackaGames Map , with tile management and drawing handled at the parent level. size() - Return the number of tiles on the map. neighbours(iTile) - Return the tile's identifiers of connected tiles to the iTile th tile. clockBearing(iTile) - Retrun the list of possible movement for a mobile on the iTile th tile. clockposition(iTile, clockDir) - Return the identifier of reached tile by moving toward the clockDir direction from the iTile th tile. Mobile Class's methods: owner(self) - Retrun the owner identifier, the player number or \\(0\\) if it is a Vip. identifier(self) - Return identifier in the owner's mobile lists (starting from \\(1\\) ). mission(self) - Return the mission the mobile is in charge and \\(0\\) if it does not have any. A simple first Bot Player The idea is to create a robot, moving at random and activating a mission action if available. but before to go, set your launcher.py with a very simple configuration : gameEngine= moveit.GameEngine( matrix= [ [00, 00, 00], [00, 00, -1], [00, 00, 00] ], numberOfPlayers=1, numberOfRobot=1, tic= 20, missions= [(4, 3), (2, 5), (5, 7)] ) Moving at random: The first part is quite simple. It requires to read robot position, to get possible movements and to choose one randomly. According to the MoveIT API , an informative implementation of decide method will lookalike: def decide(self): msg= f'tic-{ self._model.tic() } | score { self._model.score(self._id) }' r1Position= self._model.mobilePosition(self._id, 1) dirs= self._model.map().clockBearing(r1Position) msg+= f' | postion {r1Position} and actions {dirs}' self._move= random.choice(dirs) msg+= f' > move {self._move}' print( msg ) return f\"move 1 {self._move}\" To notice that, removing \\(0\\) from the possible directions will allow the robot to move/explore more. It is also possible to add sleeping and rendering in the perception method to visualize the robot behavior. def perceive(self, gameState ): self._model.setOnState(gameState) self._model.render() time.sleep(0.2) Activating a mission action: It becomes trickier a litlebit. It requires to compare the position of the robot with all possible missions. It is tricky ? so create a specific method. Always prefer to create new method compared to any other solution... So let get possible mission identifiers starting at a given position: def missionOn(self, iTile): i= 1 l= [] for m in self._model.missions() : if m.start == iTile : l.append(i) i+= 1 return l From that point we can start a mission if the robot does not have one ( self._model.mobile(1, 1).mission() == 0 ) and if it is on a tile matching a mission start ( len( self.missionOn( robotPosition ) ) > 0 ). We also need to activate mission action when the robot reach the final point of the mission : robot1Position= self._model.mobilePosition(self._id, 1) robot1Mission= self._model.mobile(1, 1).mission() if robot1Position == self._model.mission( robot1Mission ).final : At this point our first bot should move randomly, and activate missions each time it is possible. Going further: Multi-Robots... The proposed FirstBot only handle one robot associated to the player. In case of multi-robot control, the FirstBot should repeat the decision process over all robots by aggregating 'mission' and 'move' orders. Then with multiple robots moving on a same environment, the AI should avoid collision. A robot cannot target a position currently taken by another robot and tow robot cannot move on the same tile.","title":"Bot Player"},{"location":"bots/#first-autonomous-player-bot","text":"MoveIt est bas\u00e9 sur HackaGames . Se r\u00e9f\u00e9rer \u00e0 cette solution pour la philosophie du moteur de jeu, et des \u00e9changes entre le Ma\u00eetre de jeu et les joueurs. Documentation de HackaGames : ktorz-net.github.io/hackagames/ Pour lancer son premier Bot sur MoveIt il faut alors \u00e9diter un script de lancement comme suit ( launch.py par exmple). import hacka.games.moveit as moveit import playground # Configure the game: gameEngine= moveit.GameEngine() # Then Go... gameMaster= moveit.GameMaster( gameEngine, randomMission=2 ) player= playground.FirstBot() gameMaster.launch( [player], gameEngine.numberOfPlayers() ) Cela supose naturellement d'avoir une class FirstBot dans un fichier playground.py , \u00e0 c\u00f4t\u00e9 de votre lanceur.","title":"First Autonomous Player (Bot)"},{"location":"bots/#blanc-bot-player","text":"MoveIt se structure comme tout jeu HackaGames avec un cycle global: wakeUp en d\u00e9but de partie et sleep en fin de partie, et un cycle rapide de tour de jeu avec perceive et decide . class FirstBot(): # Player interface : def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): pass def perceive(self, state ): pass def decide(self): return \"pass\" def sleep(self, result): print( f\"end on : {result}\" ) Dans la mesure o\u00f9 FirstBot d\u00e9finit les m\u00e9thodes appropri\u00e9es avec les param\u00e8tres coh\u00e9rents, une instance de FirstBot pourra jouer dans un jeu HackaGames . Naturellement, dans l'\u00e9tat, le r\u00e9sultat sera nul. python3 launch.py Le gameConfiguration de la m\u00e9thode wakeUp d\u00e9finit le plateau de jeu. Les cellules et comment elles sont connect\u00e9es les unes aux autres. Au passage on a d\u00e9s le wakeUp , la position des robots et le 'Market Place' avec les missions disponibles. Ensuite, la m\u00e9thode perceive avec comme param\u00e8tre state ne va renseigner que sur l'avanc\u00e9e du jeu. Le positionnement des robots sur le plateau et l'avanc\u00e9e des missions. Cependant il n'est pas utile de rentre dans le d\u00e9tail des objets gameConfiguration et state . Il est possible de charger un mod\u00e8le du jeu, avec la class GameEngine du package python moveIt . Il sera alors possible de charger la configuration du jeu et de mettre \u00e0 jour son \u00e9tat simplement: from hacka.games.moveit import GameEngine ... def wakeUp(self, playerId, numberOfPlayers, gameConfiguration ): self._id= playerId self._model= GameEngine() self._model.fromPod(gameConfiguration) # Load the model from gameConfiguration self._model.render() # Draw the game image in shot-moveIt.png def perceive(self, state ): self._model.setOnState(state) # Update the model sate Then model will be queried through its methods (look at inspect python package for instance).","title":"Blanc Bot Player"},{"location":"bots/#moveit-classes","text":"MoveIt game is mainly based on 3 classe: GameEngine : it manages the game elements and the game rules. Map : based on Hackapy::tiled.Map , it represents the environment as a graph of interconnected tiles. Mobile : the mobile objects on the Map (Robots, and Vips). Mission : the mission objects with start and final positions plus reward and owner information.","title":"MoveIt Classes"},{"location":"bots/#gameengine-classs-methods","text":"numberOfPlayers() - Return the number of players. numberOfMobiles(iPlayer=1) - Return the number of robots owned by the player identifiate as iPlayer or vips, if iPlayer=0 . mobile(iPlayer, iRobot) - Return the iRobot th robot as a Mobile instance of the player iPlayer . mobilePosition(iPlayer, iRobot) - Return the position (tile identifier) of the iRobot th robot of the player iPlayer . missions() - Return all missions tuples. mission(iMission) - Return an object describing the iMission th mission (Mission has 4 integer attributes: the start tile id, the final tile id, the expected reward by terminating the mission and the mission owner id ( \\(0\\) if the mission is free). missionsList() - Return the list of active missions identifiers. freeMissions() - Return the list of mission identifier not allocated to any players. tic() - Return the counter on game turn. score(iPlayer): - Return the score of the iPlayer player. map() - Return the gameEngine map.","title":"GameEngine Class's methods:"},{"location":"bots/#map-classs-methods","text":"To notice that MoveIt Map inherits from HackaGames Map , with tile management and drawing handled at the parent level. size() - Return the number of tiles on the map. neighbours(iTile) - Return the tile's identifiers of connected tiles to the iTile th tile. clockBearing(iTile) - Retrun the list of possible movement for a mobile on the iTile th tile. clockposition(iTile, clockDir) - Return the identifier of reached tile by moving toward the clockDir direction from the iTile th tile.","title":"Map Class's methods:"},{"location":"bots/#mobile-classs-methods","text":"owner(self) - Retrun the owner identifier, the player number or \\(0\\) if it is a Vip. identifier(self) - Return identifier in the owner's mobile lists (starting from \\(1\\) ). mission(self) - Return the mission the mobile is in charge and \\(0\\) if it does not have any.","title":"Mobile Class's methods:"},{"location":"bots/#a-simple-first-bot-player","text":"The idea is to create a robot, moving at random and activating a mission action if available. but before to go, set your launcher.py with a very simple configuration : gameEngine= moveit.GameEngine( matrix= [ [00, 00, 00], [00, 00, -1], [00, 00, 00] ], numberOfPlayers=1, numberOfRobot=1, tic= 20, missions= [(4, 3), (2, 5), (5, 7)] )","title":"A simple first Bot Player"},{"location":"bots/#moving-at-random","text":"The first part is quite simple. It requires to read robot position, to get possible movements and to choose one randomly. According to the MoveIT API , an informative implementation of decide method will lookalike: def decide(self): msg= f'tic-{ self._model.tic() } | score { self._model.score(self._id) }' r1Position= self._model.mobilePosition(self._id, 1) dirs= self._model.map().clockBearing(r1Position) msg+= f' | postion {r1Position} and actions {dirs}' self._move= random.choice(dirs) msg+= f' > move {self._move}' print( msg ) return f\"move 1 {self._move}\" To notice that, removing \\(0\\) from the possible directions will allow the robot to move/explore more. It is also possible to add sleeping and rendering in the perception method to visualize the robot behavior. def perceive(self, gameState ): self._model.setOnState(gameState) self._model.render() time.sleep(0.2)","title":"Moving at random:"},{"location":"bots/#activating-a-mission-action","text":"It becomes trickier a litlebit. It requires to compare the position of the robot with all possible missions. It is tricky ? so create a specific method. Always prefer to create new method compared to any other solution... So let get possible mission identifiers starting at a given position: def missionOn(self, iTile): i= 1 l= [] for m in self._model.missions() : if m.start == iTile : l.append(i) i+= 1 return l From that point we can start a mission if the robot does not have one ( self._model.mobile(1, 1).mission() == 0 ) and if it is on a tile matching a mission start ( len( self.missionOn( robotPosition ) ) > 0 ). We also need to activate mission action when the robot reach the final point of the mission : robot1Position= self._model.mobilePosition(self._id, 1) robot1Mission= self._model.mobile(1, 1).mission() if robot1Position == self._model.mission( robot1Mission ).final : At this point our first bot should move randomly, and activate missions each time it is possible.","title":"Activating a mission action:"},{"location":"bots/#going-further-multi-robots","text":"The proposed FirstBot only handle one robot associated to the player. In case of multi-robot control, the FirstBot should repeat the decision process over all robots by aggregating 'mission' and 'move' orders. Then with multiple robots moving on a same environment, the AI should avoid collision. A robot cannot target a position currently taken by another robot and tow robot cannot move on the same tile.","title":"Going further: Multi-Robots..."},{"location":"dijkstra/","text":"Distances and Paths Efficient MoveIt AI requires evaluation of distance in graph and path computation. In this tutorial we consider only on robot on the map. Distance with Disjkstra Let consider a graph, Dijkstra's algorithm compute the shortest path from a given origin node toward a destination node. Starting from the origin node, Dijkstra visits all possible connections, in a recursive way, until the destination node is founded. By considering that, the destination node would be the last visited one, Dijkstra computes a distances' dictionary from the origin node toward all the other nodes. In MoveIt game, the algorithm can be simplified considering that all weight is \\(1\\) . Furthermore, nodes are similar to tiles in our model. Let consider a simple graph of \\(8\\) nodes: Starting from node \\(5\\) , Simplified-Dijkstra will first find \\(2\\) , \\(4\\) and \\(7\\) at distance \\(1\\) , then \\(1\\) , \\(3\\) , \\(6\\) and \\(8\\) at distance 2. The algorithm deep into the graph until all nodes are visited, ring by ring. def computeDistances(self, iTile): # Initialize distances to 0: dists= [iTile] + [0 for i in range( self._model.map().size() )] # Initialize step from iTile: ringNodes= self._model.map().neighbours(iTile) ringDistance= 1 # while theire is nodes to visit while len(ringNodes) > 0 : nextNodes= [] # Visit all step nodes: for node in ringNodes : # Update distance information dists[node]= ringDistance for node in ringNodes : # Search for new tile to visit: neighbours= self._model.map().neighbours(node) for candidate in neighbours : if dists[candidate] == 0 : nextNodes.append(candidate) # swith to the next step. ringNodes= nextNodes ringDistance+= 1 # Correct 0 distance: dists[iTile]= 0 return dists At this point, we compute the distances considering one origin node. The idea is to apply this method to all nodes, at the start time (into the wakeUp method) to fill an entire matrix. x 1 2 3 4 5 6 7 8 1: 2: 3: 4: 5: 2 1 2 1 0 2 1 2 6: 7: 8: Path Planning So it is possible to consider that we have a distance matrix structure over all couple of nodes (named _distances ). From that statement, going from a tile A to a tile B consists in moving step by step, by selecting the next node with the minimal distance to B . 1: moveToward selects the next appropriate move. def moveToward(self, iTile, iTarget): # If no need to move: if iTile == iTarget : return 0, iTile # Get candidates: clockdirs= self._model.map().clockBearing(iTile) nextTiles= self._model.map().neighbours(iTile) selectedDir= clockdirs[0] selectedNext= nextTiles[0] # Test all candidates: for clock, tile in zip( clockdirs, nextTiles ) : if self._distances[tile][iTarget] < self._distances[selectedNext][iTarget] : selectedDir= clock selectedNext= tile # Return the selected candidates: return selectedDir, selectedNext 2: Then, path calls moveToward until the position is reached. def path(self, iTile, iTarget): clock, tile= self.moveToward(iTile, iTarget) move= [clock] path= [tile] while tile != iTarget : clock, tile= self.moveToward(tile, iTarget) move.append( clock ) path.append( tile ) return move, path From that point it is now possible to orient robot moves toward the next mission to take or toward the current mission target. A* algorithm In A* family algorithms , we consider that we do not have an exact distance matrix, and that it requires too much computation to create it. However, it is considered true that it is possible to have approximate distances, typically, Euclidean distances computed from tile centers. The approximate distance is considered as an heuristic to guide the path planning. At each time step, the next node is selected accordingly to the heuristic (the closest one to the target), but backtrack mechanism is added if the search fall in a deadlock. More detail on wikipedia .","title":"Distance and Paths"},{"location":"dijkstra/#distances-and-paths","text":"Efficient MoveIt AI requires evaluation of distance in graph and path computation. In this tutorial we consider only on robot on the map.","title":"Distances and Paths"},{"location":"dijkstra/#distance-with-disjkstra","text":"Let consider a graph, Dijkstra's algorithm compute the shortest path from a given origin node toward a destination node. Starting from the origin node, Dijkstra visits all possible connections, in a recursive way, until the destination node is founded. By considering that, the destination node would be the last visited one, Dijkstra computes a distances' dictionary from the origin node toward all the other nodes. In MoveIt game, the algorithm can be simplified considering that all weight is \\(1\\) . Furthermore, nodes are similar to tiles in our model. Let consider a simple graph of \\(8\\) nodes: Starting from node \\(5\\) , Simplified-Dijkstra will first find \\(2\\) , \\(4\\) and \\(7\\) at distance \\(1\\) , then \\(1\\) , \\(3\\) , \\(6\\) and \\(8\\) at distance 2. The algorithm deep into the graph until all nodes are visited, ring by ring. def computeDistances(self, iTile): # Initialize distances to 0: dists= [iTile] + [0 for i in range( self._model.map().size() )] # Initialize step from iTile: ringNodes= self._model.map().neighbours(iTile) ringDistance= 1 # while theire is nodes to visit while len(ringNodes) > 0 : nextNodes= [] # Visit all step nodes: for node in ringNodes : # Update distance information dists[node]= ringDistance for node in ringNodes : # Search for new tile to visit: neighbours= self._model.map().neighbours(node) for candidate in neighbours : if dists[candidate] == 0 : nextNodes.append(candidate) # swith to the next step. ringNodes= nextNodes ringDistance+= 1 # Correct 0 distance: dists[iTile]= 0 return dists At this point, we compute the distances considering one origin node. The idea is to apply this method to all nodes, at the start time (into the wakeUp method) to fill an entire matrix. x 1 2 3 4 5 6 7 8 1: 2: 3: 4: 5: 2 1 2 1 0 2 1 2 6: 7: 8:","title":"Distance with Disjkstra"},{"location":"dijkstra/#path-planning","text":"So it is possible to consider that we have a distance matrix structure over all couple of nodes (named _distances ). From that statement, going from a tile A to a tile B consists in moving step by step, by selecting the next node with the minimal distance to B . 1: moveToward selects the next appropriate move. def moveToward(self, iTile, iTarget): # If no need to move: if iTile == iTarget : return 0, iTile # Get candidates: clockdirs= self._model.map().clockBearing(iTile) nextTiles= self._model.map().neighbours(iTile) selectedDir= clockdirs[0] selectedNext= nextTiles[0] # Test all candidates: for clock, tile in zip( clockdirs, nextTiles ) : if self._distances[tile][iTarget] < self._distances[selectedNext][iTarget] : selectedDir= clock selectedNext= tile # Return the selected candidates: return selectedDir, selectedNext 2: Then, path calls moveToward until the position is reached. def path(self, iTile, iTarget): clock, tile= self.moveToward(iTile, iTarget) move= [clock] path= [tile] while tile != iTarget : clock, tile= self.moveToward(tile, iTarget) move.append( clock ) path.append( tile ) return move, path From that point it is now possible to orient robot moves toward the next mission to take or toward the current mission target.","title":"Path Planning"},{"location":"dijkstra/#a-algorithm","text":"In A* family algorithms , we consider that we do not have an exact distance matrix, and that it requires too much computation to create it. However, it is considered true that it is possible to have approximate distances, typically, Euclidean distances computed from tile centers. The approximate distance is considered as an heuristic to guide the path planning. At each time step, the next node is selected accordingly to the heuristic (the closest one to the target), but backtrack mechanism is added if the search fall in a deadlock. More detail on wikipedia .","title":"A* algorithm"},{"location":"faq/","text":"Frequent Asked Question Update HackaGames and MoveIt Using git and pip : git -C hackagames pull git -C game-moveit pull pip install ./hackagames pip install ./game-moveit Make launcher 'configurable' . You can easely load and dumps structured data between python and files. Json offer an simple an elegent solution to exange dictionaries, for instance. From the json side ( config-7x10.json ): { \"matrix\": [ [ 0, 0, -1, 0, -1, 0, 0, 0, 0, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, -1, 0], [ 0, 0, -1, -1, -1, -1, 0, 0, -1, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, -1, 0, -1, -1, 0, 0, -1, -1, -1], [ 0, -1, 0, -1, -1, 0, 0, -1, -1, -1], [ 0, 0, 0, 0, 0, 0, 0, -1, -1, -1] ], \"tic\": 50 } On the python side: import json with open(\"./config-7x10.json\") as file: dico= json.load(file) # Configure the game: gameEngine= moveit.GameEngine( matrix= dico['matrix'], tic= dico['tic'], numberOfPlayers=1, numberOfRobot=1, numberOfPVips= 1 ) Or: open(sys.argv[1]) if you want to set the configuration file on the command line.","title":"F.A.Q"},{"location":"faq/#frequent-asked-question","text":"","title":"Frequent Asked Question"},{"location":"faq/#update-hackagames-and-moveit","text":"Using git and pip : git -C hackagames pull git -C game-moveit pull pip install ./hackagames pip install ./game-moveit","title":"Update HackaGames and MoveIt"},{"location":"faq/#make-launcher-configurable","text":"You can easely load and dumps structured data between python and files. Json offer an simple an elegent solution to exange dictionaries, for instance. From the json side ( config-7x10.json ): { \"matrix\": [ [ 0, 0, -1, 0, -1, 0, 0, 0, 0, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, -1, 0], [ 0, 0, -1, -1, -1, -1, 0, 0, -1, 0], [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [ 0, -1, 0, -1, -1, 0, 0, -1, -1, -1], [ 0, -1, 0, -1, -1, 0, 0, -1, -1, -1], [ 0, 0, 0, 0, 0, 0, 0, -1, -1, -1] ], \"tic\": 50 } On the python side: import json with open(\"./config-7x10.json\") as file: dico= json.load(file) # Configure the game: gameEngine= moveit.GameEngine( matrix= dico['matrix'], tic= dico['tic'], numberOfPlayers=1, numberOfRobot=1, numberOfPVips= 1 ) Or: open(sys.argv[1]) if you want to set the configuration file on the command line.","title":"Make launcher 'configurable'."},{"location":"iterative/","text":"Iterative Development Agile Development ( wikipedia ) Borns with a Manifesto (Beck et all. 2021) focusing development over \\(4\\) values: Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan We can extract severals lessons: Project Development is not an exact science. It sound like an utopia but it's seek for efficiency. Development rythmed with iterations seems to be a good idea. Example with Scrum It is one implementation of Agile methode. It introduces notions as: Daily Scrum metting - or Standup meetting (team activity) Sprint (temporal decomposition) Product backlog / sprint backlog (object) Srum Master (Role) It highligts Agile Development with iterative process as the core element of the method. But, a strong usage of Scrum can put processes and tools before Individuals and interactions . What do we need A solution","title":"Iterative process"},{"location":"iterative/#iterative-development","text":"Agile Development ( wikipedia ) Borns with a Manifesto (Beck et all. 2021) focusing development over \\(4\\) values: Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan We can extract severals lessons: Project Development is not an exact science. It sound like an utopia but it's seek for efficiency. Development rythmed with iterations seems to be a good idea.","title":"Iterative Development"},{"location":"iterative/#example-with-scrum","text":"It is one implementation of Agile methode. It introduces notions as: Daily Scrum metting - or Standup meetting (team activity) Sprint (temporal decomposition) Product backlog / sprint backlog (object) Srum Master (Role) It highligts Agile Development with iterative process as the core element of the method. But, a strong usage of Scrum can put processes and tools before Individuals and interactions .","title":"Example with Scrum"},{"location":"iterative/#what-do-we-need","text":"A solution","title":"What do we need"},{"location":"rules/","text":"R\u00e9gles du jeux MoveIt consiste donc \u00e0 d\u00e9placer des robots dans une carte pour r\u00e9alis\u00e9r des missions. Un randu visuel est propos\u00e9 \u00e0 l'aide de la librairie graphique Cairo . Ci appr\u00e9s une capture d'\u00e9crant du jeux: On peu y voir 3 robots rouges ( R-1 , R-2 et R-3 ) pouvant se d\u00e9placer sur un graphe compos\u00e9 de 48 cellules/dalles ( tiles en anglais) Un Market-Place propose des missions \u00e0 r\u00e9aliser par les robots. Jouer: Nous supposons ici que vous avais clonez MoveIt et que vous l'avez install\u00e9 sur votre machine. Le r\u00e9pertoire play contiend un certaint nombre de scripts ( \\(2\\) pour l'instant), permetant de lancer MoveIT dans diff\u00e9rente configuration dans un mode interactif. Vous, humain, jouez au jeu en envoyant vos commands dans le terminal. Lancer le jeu dans son mode le plus basic: python3 ./game-moveit/play/debug.py Une repr\u00e9sentation du jeux est mise \u00e0 jour \u00e0 chaque pas-de-temps dans ./shot-moveIt.png pour avoir une id\u00e9e de l'\u00e9tat du jeu est prendre les bonnes d\u00e9cisions. Les d\u00e9cisions consernent en premier lieu les d\u00e9placement des robots et se code de la pa\u00e7on suivante: move iRobot direction . Chaque robot donc est identifi\u00e9 par un num\u00e9ro de \\(1\\) \u00e0 \\(n\\) avec \\(n\\) robots. La direction est cod\u00e9 sur une logique horaire ( Clock Bearing ). Le robot peut se d\u00e9pacer \u00e0 midi, 3 heure, 6 heure ou 9 heure. Par exemple avec trois robots: move 1 9 2 12 3 3 Cet commande indique que le robot-1 bouge dans la direction 9H, le robot-2 vers 12h et le robot-3 vers 3H. Une direction \\(0h\\) indiquera que le rbots reste sur sa position (action par d\u00e9fault). Les robots peuvent r\u00e9aliser une mission, soit pour la d\u00e9buter, soit pour la finaliser. Dans ce cadre, le robot doit \u00eatre sur la bonne possition pour faire une action mission : mission iRobot iMission . iMission est l'identifiant de la mission \u00e0 activer ou a finaliser entre \\(1\\) et \\(m\\) avec \\(m\\) missions sur le jeu. L'example suivant indique que le robot-2 active la mission 8 . mission 2 8 \u00e0 noter que \\(2\\) mission ne raporteront pas n\u00e9cc\u00e9ssairement le m\u00eame nombre de cr\u00e9dit (\u00a2). L'\u00e9quipe de robot \u00e0 un nombre de tours (tic) limit\u00e9 pour r\u00e9aliser un maximun de mission. Aussi, il est pr\u00e9f\u00e9rable de faire les actions missions en m\u00eame temps que des d\u00e9placements des autres robots, par exemple: mission 2 8 move 1 0 3 12 Pour un version plus riche du jeu: python3 ./game-moveit/play/moveIt.py Version multi-joueur","title":"Game Rules"},{"location":"rules/#regles-du-jeux","text":"MoveIt consiste donc \u00e0 d\u00e9placer des robots dans une carte pour r\u00e9alis\u00e9r des missions. Un randu visuel est propos\u00e9 \u00e0 l'aide de la librairie graphique Cairo . Ci appr\u00e9s une capture d'\u00e9crant du jeux: On peu y voir 3 robots rouges ( R-1 , R-2 et R-3 ) pouvant se d\u00e9placer sur un graphe compos\u00e9 de 48 cellules/dalles ( tiles en anglais) Un Market-Place propose des missions \u00e0 r\u00e9aliser par les robots.","title":"R\u00e9gles du jeux"},{"location":"rules/#jouer","text":"Nous supposons ici que vous avais clonez MoveIt et que vous l'avez install\u00e9 sur votre machine. Le r\u00e9pertoire play contiend un certaint nombre de scripts ( \\(2\\) pour l'instant), permetant de lancer MoveIT dans diff\u00e9rente configuration dans un mode interactif. Vous, humain, jouez au jeu en envoyant vos commands dans le terminal. Lancer le jeu dans son mode le plus basic: python3 ./game-moveit/play/debug.py Une repr\u00e9sentation du jeux est mise \u00e0 jour \u00e0 chaque pas-de-temps dans ./shot-moveIt.png pour avoir une id\u00e9e de l'\u00e9tat du jeu est prendre les bonnes d\u00e9cisions. Les d\u00e9cisions consernent en premier lieu les d\u00e9placement des robots et se code de la pa\u00e7on suivante: move iRobot direction . Chaque robot donc est identifi\u00e9 par un num\u00e9ro de \\(1\\) \u00e0 \\(n\\) avec \\(n\\) robots. La direction est cod\u00e9 sur une logique horaire ( Clock Bearing ). Le robot peut se d\u00e9pacer \u00e0 midi, 3 heure, 6 heure ou 9 heure. Par exemple avec trois robots: move 1 9 2 12 3 3 Cet commande indique que le robot-1 bouge dans la direction 9H, le robot-2 vers 12h et le robot-3 vers 3H. Une direction \\(0h\\) indiquera que le rbots reste sur sa position (action par d\u00e9fault). Les robots peuvent r\u00e9aliser une mission, soit pour la d\u00e9buter, soit pour la finaliser. Dans ce cadre, le robot doit \u00eatre sur la bonne possition pour faire une action mission : mission iRobot iMission . iMission est l'identifiant de la mission \u00e0 activer ou a finaliser entre \\(1\\) et \\(m\\) avec \\(m\\) missions sur le jeu. L'example suivant indique que le robot-2 active la mission 8 . mission 2 8 \u00e0 noter que \\(2\\) mission ne raporteront pas n\u00e9cc\u00e9ssairement le m\u00eame nombre de cr\u00e9dit (\u00a2). L'\u00e9quipe de robot \u00e0 un nombre de tours (tic) limit\u00e9 pour r\u00e9aliser un maximun de mission. Aussi, il est pr\u00e9f\u00e9rable de faire les actions missions en m\u00eame temps que des d\u00e9placements des autres robots, par exemple: mission 2 8 move 1 0 3 12 Pour un version plus riche du jeu: python3 ./game-moveit/play/moveIt.py","title":"Jouer:"},{"location":"rules/#version-multi-joueur","text":"","title":"Version multi-joueur"},{"location":"tests/","text":"Test-Driven Development The idea is to design tests first (more on WikiPedia ) In Python: the tool pytest allows developper to test the code very easely. Example with Path: Initialize a test environment: from hacka.games.moveit import GameEngine import bot def test_gamemaster_distances_path(): game= GameEngine( matrix= [ [00, 00, 00, 00], [-1, 00, -1, -1], [00, 00, 00, 00], [00, -1, -1, 00] ], tic= 10, missions= [(4, 5), (7, 8)] ) myBot= bot.VoidBot() myBot.wakeUp( 1, 1, game.asPod() ) Then test based on assert : assert myBot._model.map().size() == 11 assert myBot._distances == [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [ 1, 0, 1, 2, 3, 2, 4, 3, 4, 5, 5, 6], [ 2, 1, 0, 1, 2, 1, 3, 2, 3, 4, 4, 5], [ 3, 2, 1, 0, 1, 2, 4, 3, 4, 5, 5, 6], [ 4, 3, 2, 1, 0, 3, 5, 4, 5, 6, 6, 7], [ 5, 2, 1, 2, 3, 0, 2, 1, 2, 3, 3, 4], [ 6, 4, 3, 4, 5, 2, 0, 1, 2, 3, 1, 4], [ 7, 3, 2, 3, 4, 1, 1, 0, 1, 2, 2, 3], [ 8, 4, 3, 4, 5, 2, 2, 1, 0, 1, 3, 2], [ 9, 5, 4, 5, 6, 3, 3, 2, 1, 0, 4, 1], [10, 5, 4, 5, 6, 3, 1, 2, 3, 4, 0, 5], [11, 6, 5, 6, 7, 4, 4, 3, 2, 1, 5, 0] ] assert myBot.moveToward(1, 2) == (3, 2) assert myBot.moveToward(4, 4) == (0, 4) assert myBot.moveToward(5, 11) == (6, 7) assert myBot.path(1, 11) == ( [3, 6, 6, 3, 3, 6], [2, 5, 7, 8, 9, 11] )","title":"Test driven"},{"location":"tests/#test-driven-development","text":"The idea is to design tests first (more on WikiPedia ) In Python: the tool pytest allows developper to test the code very easely.","title":"Test-Driven Development"},{"location":"tests/#example-with-path","text":"Initialize a test environment: from hacka.games.moveit import GameEngine import bot def test_gamemaster_distances_path(): game= GameEngine( matrix= [ [00, 00, 00, 00], [-1, 00, -1, -1], [00, 00, 00, 00], [00, -1, -1, 00] ], tic= 10, missions= [(4, 5), (7, 8)] ) myBot= bot.VoidBot() myBot.wakeUp( 1, 1, game.asPod() ) Then test based on assert : assert myBot._model.map().size() == 11 assert myBot._distances == [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [ 1, 0, 1, 2, 3, 2, 4, 3, 4, 5, 5, 6], [ 2, 1, 0, 1, 2, 1, 3, 2, 3, 4, 4, 5], [ 3, 2, 1, 0, 1, 2, 4, 3, 4, 5, 5, 6], [ 4, 3, 2, 1, 0, 3, 5, 4, 5, 6, 6, 7], [ 5, 2, 1, 2, 3, 0, 2, 1, 2, 3, 3, 4], [ 6, 4, 3, 4, 5, 2, 0, 1, 2, 3, 1, 4], [ 7, 3, 2, 3, 4, 1, 1, 0, 1, 2, 2, 3], [ 8, 4, 3, 4, 5, 2, 2, 1, 0, 1, 3, 2], [ 9, 5, 4, 5, 6, 3, 3, 2, 1, 0, 4, 1], [10, 5, 4, 5, 6, 3, 1, 2, 3, 4, 0, 5], [11, 6, 5, 6, 7, 4, 4, 3, 2, 1, 5, 0] ] assert myBot.moveToward(1, 2) == (3, 2) assert myBot.moveToward(4, 4) == (0, 4) assert myBot.moveToward(5, 11) == (6, 7) assert myBot.path(1, 11) == ( [3, 6, 6, 3, 3, 6], [2, 5, 7, 8, 9, 11] )","title":"Example with Path:"}]}